use anyhow::Result;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::RwLock;
use tower_lsp::jsonrpc::Result as LspResult;
use tower_lsp::lsp_types::*;
use tower_lsp::{Client, LanguageServer, LspService, Server};
use tracing::{info, warn};

use crate::ai_engine::AIEngine;

pub struct UniversalAILanguageServer {
    client: Client,
    ai_engine: Arc<RwLock<AIEngine>>,
}

impl UniversalAILanguageServer {
    pub fn new(client: Client, ai_engine: Arc<RwLock<AIEngine>>) -> Self {
        Self { client, ai_engine }
    }
}

#[tower_lsp::async_trait]
impl LanguageServer for UniversalAILanguageServer {
    async fn initialize(&self, _: InitializeParams) -> LspResult<InitializeResult> {
        info!("Language server initializing...");
        
        Ok(InitializeResult {
            capabilities: ServerCapabilities {
                text_document_sync: Some(TextDocumentSyncCapability::Kind(
                    TextDocumentSyncKind::INCREMENTAL,
                )),
                completion_provider: Some(CompletionOptions {
                    resolve_provider: Some(false),
                    trigger_characters: Some(vec![".".to_string(), "(".to_string(), " ".to_string()]),
                    work_done_progress_options: Default::default(),
                    all_commit_characters: None,
                    completion_item: None,
                }),
                hover_provider: Some(HoverProviderCapability::Simple(true)),
                diagnostic_provider: Some(DiagnosticServerCapabilities::Options(
                    DiagnosticOptions {
                        identifier: Some("universal-ai-dev-assistant".to_string()),
                        inter_file_dependencies: true,
                        workspace_diagnostics: false,
                        work_done_progress_options: Default::default(),
                    },
                )),
                code_action_provider: Some(CodeActionProviderCapability::Simple(true)),
                ..ServerCapabilities::default()
            },
            server_info: Some(ServerInfo {
                name: "Universal AI Development Assistant".to_string(),
                version: Some(env!("CARGO_PKG_VERSION").to_string()),
            }),
        })
    }

    async fn initialized(&self, _: InitializedParams) {
        info!("Language server initialized!");
        
        self.client
            .log_message(MessageType::INFO, "Universal AI Development Assistant ready!")
            .await;
    }

    async fn shutdown(&self) -> LspResult<()> {
        info!("Language server shutting down...");
        Ok(())
    }

    async fn completion(&self, params: CompletionParams) -> LspResult<Option<CompletionResponse>> {
        let uri = params.text_document_position.text_document.uri;
        let position = params.text_document_position.position;
        
        info!("Completion requested for {} at {}:{}", uri, position.line, position.character);

        // Get document content (this would normally come from document store)
        let document_content = self.get_document_content(&uri).await;
        
        if let Ok(content) = document_content {
            let language = self.detect_language_from_uri(&uri);
            let cursor_position = self.calculate_cursor_position(&content, &position);
            
            let completion_request = crate::CompletionRequest {
                code: content,
                language,
                cursor_position,
                context: None,
            };
            
            let ai_engine = self.ai_engine.read().await;
            if let Ok(suggestions) = ai_engine.complete_code(&completion_request).await {
                let completion_items: Vec<CompletionItem> = suggestions
                    .into_iter()
                    .enumerate()
                    .map(|(i, suggestion)| CompletionItem {
                        label: suggestion.clone(),
                        kind: Some(CompletionItemKind::TEXT),
                        detail: Some("AI Suggestion".to_string()),
                        documentation: Some(Documentation::String(
                            "Generated by Universal AI Development Assistant".to_string(),
                        )),
                        sort_text: Some(format!("{:02}", i)),
                        insert_text: Some(suggestion),
                        ..CompletionItem::default()
                    })
                    .collect();

                return Ok(Some(CompletionResponse::Array(completion_items)));
            }
        }

        Ok(None)
    }

    async fn hover(&self, params: HoverParams) -> LspResult<Option<Hover>> {
        let uri = params.text_document_position_params.text_document.uri;
        let position = params.text_document_position_params.position;
        
        info!("Hover requested for {} at {}:{}", uri, position.line, position.character);

        // Get word at position
        if let Ok(content) = self.get_document_content(&uri).await {
            let word = self.get_word_at_position(&content, &position);
            
            if !word.is_empty() {
                let hover_content = format!(
                    "**Universal AI Assistant**\n\nSymbol: `{}`\n\nAI-powered analysis available.",
                    word
                );
                
                return Ok(Some(Hover {
                    contents: HoverContents::Markup(MarkupContent {
                        kind: MarkupKind::Markdown,
                        value: hover_content,
                    }),
                    range: None,
                }));
            }
        }

        Ok(None)
    }

    async fn diagnostic(
        &self,
        params: DocumentDiagnosticParams,
    ) -> LspResult<DocumentDiagnosticReportResult> {
        let uri = params.text_document.uri;
        
        info!("Diagnostics requested for {}", uri);

        if let Ok(content) = self.get_document_content(&uri).await {
            let language = self.detect_language_from_uri(&uri);
            
            // Perform AI-powered analysis
            let completion_request = crate::CompletionRequest {
                code: content,
                language,
                cursor_position: 0,
                context: None,
            };
            
            let ai_engine = self.ai_engine.read().await;
            if let Ok(analysis) = ai_engine.analyze_code(&completion_request).await {
                let mut diagnostics = Vec::new();
                
                // Convert security concerns to diagnostics
                if let Some(security_concerns) = analysis["security_concerns"].as_array() {
                    for concern in security_concerns {
                        if let (Some(message), Some(line)) = (
                            concern["message"].as_str(),
                            concern["line"].as_u64(),
                        ) {
                            diagnostics.push(Diagnostic {
                                range: Range {
                                    start: Position {
                                        line: (line - 1) as u32,
                                        character: 0,
                                    },
                                    end: Position {
                                        line: (line - 1) as u32,
                                        character: 100,
                                    },
                                },
                                severity: Some(DiagnosticSeverity::WARNING),
                                code: Some(NumberOrString::String("security".to_string())),
                                source: Some("Universal AI Assistant".to_string()),
                                message: message.to_string(),
                                ..Diagnostic::default()
                            });
                        }
                    }
                }
                
                // Convert issues to diagnostics
                if let Some(issues) = analysis["issues"].as_array() {
                    for issue in issues {
                        if let Some(message) = issue["message"].as_str() {
                            diagnostics.push(Diagnostic {
                                range: Range {
                                    start: Position { line: 0, character: 0 },
                                    end: Position { line: 0, character: 100 },
                                },
                                severity: Some(DiagnosticSeverity::INFO),
                                code: Some(NumberOrString::String("analysis".to_string())),
                                source: Some("Universal AI Assistant".to_string()),
                                message: message.to_string(),
                                ..Diagnostic::default()
                            });
                        }
                    }
                }
                
                return Ok(DocumentDiagnosticReportResult::Report(
                    DocumentDiagnosticReport::Full(RelatedFullDocumentDiagnosticReport {
                        related_documents: None,
                        full_document_diagnostic_report: FullDocumentDiagnosticReport {
                            result_id: None,
                            items: diagnostics,
                        },
                    }),
                ));
            }
        }

        Ok(DocumentDiagnosticReportResult::Report(
            DocumentDiagnosticReport::Full(RelatedFullDocumentDiagnosticReport {
                related_documents: None,
                full_document_diagnostic_report: FullDocumentDiagnosticReport {
                    result_id: None,
                    items: vec![],
                },
            }),
        ))
    }

    async fn code_action(&self, params: CodeActionParams) -> LspResult<Option<CodeActionResponse>> {
        let uri = params.text_document.uri;
        
        info!("Code action requested for {}", uri);

        let mut actions = Vec::new();
        
        // Add AI-powered code actions
        actions.push(CodeActionOrCommand::CodeAction(CodeAction {
            title: "🤖 AI Analysis".to_string(),
            kind: Some(CodeActionKind::QUICKFIX),
            diagnostics: None,
            edit: None,
            command: Some(Command {
                title: "Run AI Analysis".to_string(),
                command: "universal-ai.analyze".to_string(),
                arguments: Some(vec![serde_json::to_value(&uri).unwrap()]),
            }),
            is_preferred: Some(true),
            disabled: None,
            data: None,
        }));
        
        actions.push(CodeActionOrCommand::CodeAction(CodeAction {
            title: "🛡️ Security Scan".to_string(),
            kind: Some(CodeActionKind::SOURCE_ORGANIZE_IMPORTS),
            diagnostics: None,
            edit: None,
            command: Some(Command {
                title: "Run Security Scan".to_string(),
                command: "universal-ai.security-scan".to_string(),
                arguments: Some(vec![serde_json::to_value(&uri).unwrap()]),
            }),
            is_preferred: Some(false),
            disabled: None,
            data: None,
        }));

        Ok(Some(actions))
    }
}

impl UniversalAILanguageServer {
    async fn get_document_content(&self, uri: &Url) -> Result<String> {
        // In a real implementation, this would get content from the document store
        // For now, try to read from file system
        if uri.scheme() == "file" {
            let path = uri.to_file_path().map_err(|_| anyhow::anyhow!("Invalid file path"))?;
            let content = tokio::fs::read_to_string(path).await?;
            Ok(content)
        } else {
            Err(anyhow::anyhow!("Unsupported URI scheme"))
        }
    }

    fn detect_language_from_uri(&self, uri: &Url) -> String {
        let path = uri.path();
        
        if path.ends_with(".py") {
            "python".to_string()
        } else if path.ends_with(".js") || path.ends_with(".jsx") {
            "javascript".to_string()
        } else if path.ends_with(".ts") || path.ends_with(".tsx") {
            "typescript".to_string()
        } else if path.ends_with(".rs") {
            "rust".to_string()
        } else if path.ends_with(".go") {
            "go".to_string()
        } else if path.ends_with(".java") {
            "java".to_string()
        } else if path.ends_with(".cpp") || path.ends_with(".cc") || path.ends_with(".cxx") {
            "cpp".to_string()
        } else if path.ends_with(".c") {
            "c".to_string()
        } else {
            "text".to_string()
        }
    }

    fn calculate_cursor_position(&self, content: &str, position: &Position) -> usize {
        let lines: Vec<&str> = content.lines().collect();
        let mut cursor_pos = 0;
        
        for (i, line) in lines.iter().enumerate() {
            if i < position.line as usize {
                cursor_pos += line.len() + 1; // +1 for newline
            } else if i == position.line as usize {
                cursor_pos += std::cmp::min(position.character as usize, line.len());
                break;
            }
        }
        
        cursor_pos
    }

    fn get_word_at_position(&self, content: &str, position: &Position) -> String {
        let lines: Vec<&str> = content.lines().collect();
        
        if let Some(line) = lines.get(position.line as usize) {
            let chars: Vec<char> = line.chars().collect();
            let char_pos = position.character as usize;
            
            if char_pos < chars.len() {
                // Find word boundaries
                let mut start = char_pos;
                let mut end = char_pos;
                
                // Go backwards to find start
                while start > 0 && chars[start - 1].is_alphanumeric() {
                    start -= 1;
                }
                
                // Go forwards to find end
                while end < chars.len() && chars[end].is_alphanumeric() {
                    end += 1;
                }
                
                return chars[start..end].iter().collect();
            }
        }
        
        String::new()
    }
}

pub async fn start_language_server(ai_engine: Arc<RwLock<AIEngine>>) -> Result<()> {
    let stdin = tokio::io::stdin();
    let stdout = tokio::io::stdout();

    let (service, socket) = LspService::new(|client| {
        UniversalAILanguageServer::new(client, ai_engine)
    });
    
    info!("Starting Language Server Protocol server...");
    Server::new(stdin, stdout, socket).serve(service).await;
    
    Ok(())
}