use anyhow::Result;
use colored::*;
use dialoguer::{theme::ColorfulTheme, Select, Confirm, Input};
use std::path::PathBuf;
use tokio::fs;
use serde::{Deserialize, Serialize};

use crate::client::Client;

#[derive(Debug, Serialize, Deserialize)]
pub struct FixRequest {
    pub session_id: Option<String>,
    pub message: String,
    pub current_file: Option<String>,
    pub selected_text: Option<TextSelection>,
    pub context_files: Vec<String>,
    pub intent_hint: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TextSelection {
    pub start_line: usize,
    pub start_column: usize,
    pub end_line: usize,
    pub end_column: usize,
    pub text: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct FixResponse {
    pub success: bool,
    pub response: ConversationResponse,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ConversationResponse {
    pub session_id: String,
    pub ai_response: String,
    pub intent: String,
    pub confidence_score: f32,
    pub code_changes: Option<Vec<CodeChange>>,
    pub suggested_actions: Vec<SuggestedAction>,
    pub file_references: Vec<String>,
    pub follow_up_questions: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CodeChange {
    pub file_path: String,
    pub change_type: String,
    pub old_content: Option<String>,
    pub new_content: String,
    pub description: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SuggestedAction {
    pub action_type: String,
    pub description: String,
    pub command: Option<String>,
    pub priority: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ErrorSearchRequest {
    pub error_message: String,
    pub workspace_paths: Vec<String>,
}

pub async fn run_fix(
    error_message: Option<String>,
    file_path: Option<PathBuf>,
    auto_apply: bool,
    search_solutions: bool,
    client: &Client,
) -> Result<()> {
    println!("{}", "üîß AI Hata D√ºzeltici".bright_red().bold());
    println!();

    // Hata mesajƒ±nƒ± al
    let error_msg = if let Some(msg) = error_message {
        msg
    } else {
        get_error_message_interactively().await?
    };

    println!("{} {}", "‚ùå Hata mesajƒ±:".bright_red(), error_msg.bright_white());
    println!();

    // Hata tipini analiz et
    let error_type = analyze_error_type(&error_msg);
    println!("{} {}", "üîç Tespit edilen hata tipi:".bright_blue(), error_type.bright_yellow());

    // ƒ∞lgili dosyayƒ± belirle
    let target_file = if let Some(path) = file_path {
        Some(path)
    } else {
        extract_file_from_error(&error_msg).await?
    };

    if let Some(ref file) = target_file {
        println!("{} {}", "üìÅ ƒ∞lgili dosya:".bright_blue(), file.display().to_string().bright_white());
    }

    // Benzer hata √ß√∂z√ºmlerini ara
    if search_solutions {
        search_error_solutions(&error_msg, client).await?;
    }

    // AI ile hata analizi ve √ß√∂z√ºm √∂nerisi
    let fix_response = get_fix_suggestions(&error_msg, &target_file, client).await?;
    
    // √á√∂z√ºm √∂nerilerini g√∂ster
    display_fix_suggestions(&fix_response, &error_msg).await?;

    // Kod deƒüi≈üikliklerini uygula
    if let Some(code_changes) = &fix_response.response.code_changes {
        if !code_changes.is_empty() {
            handle_code_changes(code_changes, auto_apply, &target_file).await?;
        }
    }

    // Follow-up actions
    handle_fix_actions(&fix_response, &error_msg, &target_file, client).await?;

    Ok(())
}

async fn get_error_message_interactively() -> Result<String> {
    println!("{}", "Hata mesajƒ±nƒ± nasƒ±l almak istiyorsunuz?".bright_cyan());
    
    let options = vec![
        "‚å®Ô∏è  Manuel olarak gir",
        "üìã Clipboard'dan yapƒ±≈ütƒ±r",
        "üìÑ Log dosyasƒ±ndan oku",
        "üîÑ Son build √ßƒ±ktƒ±sƒ±ndan al",
    ];

    let selection = Select::with_theme(&ColorfulTheme::default())
        .with_prompt("Se√ßim yapƒ±n")
        .items(&options)
        .interact()?;

    match selection {
        0 => {
            // Manuel giri≈ü
            let error: String = Input::with_theme(&ColorfulTheme::default())
                .with_prompt("Hata mesajƒ±nƒ± girin")
                .allow_empty(false)
                .interact_text()?;
            Ok(error)
        }
        1 => {
            // Clipboard (basit implementasyon)
            println!("{}", "üìã Clipboard √∂zelliƒüi yakƒ±nda eklenecek!".bright_yellow());
            println!("{}", "≈ûimdilik manuel olarak girin:".dimmed());
            let error: String = Input::with_theme(&ColorfulTheme::default())
                .with_prompt("Hata mesajƒ±nƒ± girin")
                .allow_empty(false)
                .interact_text()?;
            Ok(error)
        }
        2 => {
            // Log dosyasƒ±ndan oku
            read_error_from_log().await
        }
        3 => {
            // Son build √ßƒ±ktƒ±sƒ±ndan al
            get_last_build_error().await
        }
        _ => Err(anyhow::anyhow!("Ge√ßersiz se√ßim")),
    }
}

async fn read_error_from_log() -> Result<String> {
    let log_files = find_log_files().await?;
    
    if log_files.is_empty() {
        println!("{}", "‚ö†Ô∏è Log dosyasƒ± bulunamadƒ±.".bright_yellow());
        return get_error_message_interactively().await;
    }

    let file_names: Vec<String> = log_files.iter()
        .map(|p| p.file_name().unwrap().to_string_lossy().to_string())
        .collect();

    let selection = Select::with_theme(&ColorfulTheme::default())
        .with_prompt("Hangi log dosyasƒ±nƒ± okumak istiyorsunuz?")
        .items(&file_names)
        .interact()?;

    let content = fs::read_to_string(&log_files[selection]).await?;
    
    // Son hata mesajƒ±nƒ± bul
    let lines: Vec<&str> = content.lines().collect();
    for line in lines.iter().rev() {
        if line.contains("error") || line.contains("Error") || line.contains("ERROR") {
            return Ok(line.to_string());
        }
    }

    Err(anyhow::anyhow!("Log dosyasƒ±nda hata bulunamadƒ±"))
}

async fn find_log_files() -> Result<Vec<PathBuf>> {
    let current_dir = std::env::current_dir()?;
    let mut log_files = Vec::new();

    // Yaygƒ±n log dosya isimleri
    let log_patterns = ["*.log", "error.log", "build.log", "output.log"];
    
    for pattern in &log_patterns {
        if let Ok(entries) = glob::glob(&format!("{}/**/{}", current_dir.display(), pattern)) {
            for entry in entries.flatten() {
                if entry.is_file() {
                    log_files.push(entry);
                }
            }
        }
    }

    Ok(log_files)
}

async fn get_last_build_error() -> Result<String> {
    println!("{}", "üîÑ Son build √ßƒ±ktƒ±sƒ± kontrol ediliyor...".bright_yellow());

    // Yaygƒ±n build komutlarƒ±nƒ± dene
    let build_commands = [
        ("cargo", vec!["build"]),
        ("npm", vec!["run", "build"]),
        ("make", vec![]),
        ("mvn", vec!["compile"]),
        ("gradle", vec!["build"]),
    ];

    for (cmd, args) in &build_commands {
        if std::process::Command::new("which")
            .arg(cmd)
            .output()
            .map(|output| output.status.success())
            .unwrap_or(false)
        {
            println!("{} {} √ßalƒ±≈ütƒ±rƒ±lƒ±yor...", "üî®".bright_blue(), cmd);
            
            let output = std::process::Command::new(cmd)
                .args(args)
                .output();

            if let Ok(result) = output {
                let stderr = String::from_utf8_lossy(&result.stderr);
                let stdout = String::from_utf8_lossy(&result.stdout);
                
                // Hata mesajƒ±nƒ± bul
                for line in stderr.lines().chain(stdout.lines()) {
                    if line.contains("error") || line.contains("Error") || line.contains("ERROR") {
                        return Ok(line.to_string());
                    }
                }
            }
        }
    }

    Err(anyhow::anyhow!("Build hatasƒ± bulunamadƒ±"))
}

fn analyze_error_type(error_message: &str) -> String {
    let error_lower = error_message.to_lowercase();
    
    if error_lower.contains("syntax") {
        "Syntax Error".to_string()
    } else if error_lower.contains("type") || error_lower.contains("expected") {
        "Type Error".to_string()
    } else if error_lower.contains("borrow") || error_lower.contains("moved") {
        "Ownership Error (Rust)".to_string()
    } else if error_lower.contains("undefined") || error_lower.contains("not found") {
        "Reference Error".to_string()
    } else if error_lower.contains("import") || error_lower.contains("module") {
        "Import Error".to_string()
    } else if error_lower.contains("compile") || error_lower.contains("compilation") {
        "Compilation Error".to_string()
    } else if error_lower.contains("runtime") || error_lower.contains("exception") {
        "Runtime Error".to_string()
    } else if error_lower.contains("permission") || error_lower.contains("access") {
        "Permission Error".to_string()
    } else if error_lower.contains("network") || error_lower.contains("connection") {
        "Network Error".to_string()
    } else {
        "General Error".to_string()
    }
}

async fn extract_file_from_error(error_message: &str) -> Result<Option<PathBuf>> {
    // Hata mesajƒ±ndan dosya yolunu √ßƒ±karmaya √ßalƒ±≈ü
    let file_patterns = [
        regex::Regex::new(r"([a-zA-Z0-9_/.-]+\.[a-zA-Z]+):(\d+):(\d+)").unwrap(),
        regex::Regex::new(r"at ([a-zA-Z0-9_/.-]+\.[a-zA-Z]+):(\d+)").unwrap(),
        regex::Regex::new(r"in ([a-zA-Z0-9_/.-]+\.[a-zA-Z]+)").unwrap(),
        regex::Regex::new(r"file://([a-zA-Z0-9_/.-]+\.[a-zA-Z]+)").unwrap(),
    ];

    for pattern in &file_patterns {
        if let Some(captures) = pattern.captures(error_message) {
            if let Some(file_path) = captures.get(1) {
                let path = PathBuf::from(file_path.as_str());
                if path.exists() {
                    return Ok(Some(path));
                }
            }
        }
    }

    // Dosya bulunamazsa kullanƒ±cƒ±dan sor
    let specify_file = Confirm::with_theme(&ColorfulTheme::default())
        .with_prompt("Hatayla ilgili dosyayƒ± belirtmek istiyor musunuz?")
        .default(false)
        .interact()?;

    if specify_file {
        let file_path: String = Input::with_theme(&ColorfulTheme::default())
            .with_prompt("Dosya yolu")
            .interact_text()?;
        
        let path = PathBuf::from(file_path);
        if path.exists() {
            Ok(Some(path))
        } else {
            println!("{} Dosya bulunamadƒ±: {}", "‚ö†Ô∏è".bright_yellow(), path.display());
            Ok(None)
        }
    } else {
        Ok(None)
    }
}

async fn search_error_solutions(error_message: &str, client: &Client) -> Result<()> {
    println!("{}", "üîç Benzer hata √ß√∂z√ºmleri aranƒ±yor...".bright_yellow());

    let search_request = ErrorSearchRequest {
        error_message: error_message.to_string(),
        workspace_paths: vec![std::env::current_dir()?.to_string_lossy().to_string()],
    };

    match client.post::<serde_json::Value, _>("/search/errors", &search_request).await {
        Ok(response) => {
            if let Some(results) = response["response"]["results"].as_array() {
                if !results.is_empty() {
                    println!();
                    println!("{}", "üí° Benzer Hata √á√∂z√ºmleri".bright_green().bold());
                    
                    for (i, result) in results.iter().take(3).enumerate() {
                        if let (Some(file_path), Some(content), Some(relevance)) = (
                            result["file_path"].as_str(),
                            result["content"].as_str(),
                            result["relevance_score"].as_f64()
                        ) {
                            println!("  {}. {} ({:.2})", 
                                i + 1, 
                                file_path.bright_white(), 
                                relevance
                            );
                            
                            // ƒ∞lk 100 karakteri g√∂ster
                            let preview = if content.len() > 100 {
                                format!("{}...", &content[..100])
                            } else {
                                content.to_string()
                            };
                            println!("     {}", preview.dimmed());
                        }
                    }
                    println!();
                } else {
                    println!("{}", "‚ÑπÔ∏è Benzer hata √ß√∂z√ºm√º bulunamadƒ±.".bright_blue());
                }
            }
        }
        Err(e) => {
            println!("{} {}", "‚ö†Ô∏è Hata arama hatasƒ±:".bright_yellow(), e);
        }
    }

    Ok(())
}

async fn get_fix_suggestions(
    error_message: &str,
    file_path: &Option<PathBuf>,
    client: &Client,
) -> Result<FixResponse> {
    println!("{}", "ü§ñ AI hata analizi yapƒ±lƒ±yor...".bright_yellow());

    let mut message = format!("Bu hatayƒ± analiz et ve √ß√∂z√ºm √∂ner:\n\n{}", error_message);

    // Dosya i√ßeriƒüi varsa ekle
    if let Some(file) = file_path {
        if let Ok(content) = fs::read_to_string(file).await {
            message.push_str(&format!("\n\nƒ∞lgili dosya i√ßeriƒüi:\n```\n{}\n```", content));
        }
    }

    message.push_str("\n\nL√ºtfen:\n1. Hatanƒ±n nedenini a√ßƒ±kla\n2. Adƒ±m adƒ±m √ß√∂z√ºm √∂ner\n3. D√ºzeltilmi≈ü kod ver\n4. Gelecekte nasƒ±l √∂nlenebileceƒüini a√ßƒ±kla");

    let fix_request = FixRequest {
        session_id: None,
        message,
        current_file: file_path.as_ref().map(|p| p.to_string_lossy().to_string()),
        selected_text: None,
        context_files: file_path.as_ref().map(|p| vec![p.to_string_lossy().to_string()]).unwrap_or_default(),
        intent_hint: Some("Debugging".to_string()),
    };

    let response: FixResponse = client.post("/conversation/message", &fix_request).await?;
    Ok(response)
}

async fn display_fix_suggestions(response: &FixResponse, error_message: &str) -> Result<()> {
    let conv_response = &response.response;
    
    println!("{}", "üîß AI Hata Analizi ve √á√∂z√ºm √ñnerileri".bright_green().bold());
    println!("{}", "=".repeat(80).bright_green());
    println!();
    
    // Ana analiz ve √ß√∂z√ºm
    println!("{}", conv_response.ai_response);
    println!();
    
    // G√ºven skoru
    println!("{} {:.1}%", 
        "üìä G√ºven skoru:".bright_blue(), 
        conv_response.confidence_score * 100.0
    );
    
    // √ñnerilen aksiyonlar
    if !conv_response.suggested_actions.is_empty() {
        println!();
        println!("{}", "‚ö° √ñnerilen Aksiyonlar".bright_yellow().bold());
        for action in &conv_response.suggested_actions {
            let priority_icon = match action.priority.as_str() {
                "High" => "üî¥",
                "Medium" => "üü°", 
                "Low" => "üü¢",
                _ => "‚ö™",
            };
            
            println!("  {} {} {}", 
                priority_icon, 
                action.description.bright_white(),
                action.action_type.dimmed()
            );
            
            if let Some(command) = &action.command {
                println!("    {} {}", "üíª".bright_blue(), command.bright_cyan());
            }
        }
    }
    
    // Follow-up sorular
    if !conv_response.follow_up_questions.is_empty() {
        println!();
        println!("{}", "‚ùì ƒ∞lgili Sorular".bright_cyan().bold());
        for question in &conv_response.follow_up_questions {
            println!("  {} {}", "‚Ä¢".bright_cyan(), question.bright_white());
        }
    }
    
    println!();
    Ok(())
}

async fn handle_code_changes(
    code_changes: &[CodeChange],
    auto_apply: bool,
    target_file: &Option<PathBuf>,
) -> Result<()> {
    println!("{}", "üìù Kod Deƒüi≈üiklikleri".bright_blue().bold());
    
    for (i, change) in code_changes.iter().enumerate() {
        println!("{}. {} - {}", 
            i + 1, 
            change.file_path.bright_white(), 
            change.description.bright_cyan()
        );
        
        println!("   {} {}", "üîÑ Tip:".bright_blue(), change.change_type.bright_yellow());
        
        // Kod √∂nizlemesi
        let preview = if change.new_content.len() > 200 {
            format!("{}...", &change.new_content[..200])
        } else {
            change.new_content.clone()
        };
        
        println!("   {} Yeni kod:", "üìÑ".bright_blue());
        println!("{}", format_code_preview(&preview));
        
        if let Some(old_content) = &change.old_content {
            println!("   {} Eski kod:", "üìÑ".bright_red());
            let old_preview = if old_content.len() > 200 {
                format!("{}...", &old_content[..200])
            } else {
                old_content.clone()
            };
            println!("{}", format_code_preview(&old_preview));
        }
        
        // Deƒüi≈üikliƒüi uygula
        if auto_apply {
            apply_code_change(change).await?;
            println!("{} Deƒüi≈üiklik uygulandƒ±!", "‚úÖ".bright_green());
        } else {
            let apply = Confirm::with_theme(&ColorfulTheme::default())
                .with_prompt("Bu deƒüi≈üikliƒüi uygulamak istiyor musunuz?")
                .default(true)
                .interact()?;
            
            if apply {
                apply_code_change(change).await?;
                println!("{} Deƒüi≈üiklik uygulandƒ±!", "‚úÖ".bright_green());
            } else {
                println!("{} Deƒüi≈üiklik atlandƒ±.", "‚è≠Ô∏è".bright_yellow());
            }
        }
        
        println!();
    }
    
    Ok(())
}

fn format_code_preview(code: &str) -> String {
    code.lines()
        .enumerate()
        .map(|(i, line)| format!("     {:2} ‚îÇ {}", i + 1, line))
        .collect::<Vec<_>>()
        .join("\n")
}

async fn apply_code_change(change: &CodeChange) -> Result<()> {
    let file_path = PathBuf::from(&change.file_path);
    
    match change.change_type.as_str() {
        "Create" => {
            // Yeni dosya olu≈ütur
            if let Some(parent) = file_path.parent() {
                fs::create_dir_all(parent).await?;
            }
            fs::write(&file_path, &change.new_content).await?;
        }
        "Modify" => {
            // Mevcut dosyayƒ± g√ºncelle
            if file_path.exists() {
                // Backup olu≈ütur
                let backup_path = format!("{}.backup", file_path.display());
                fs::copy(&file_path, &backup_path).await?;
                println!("   {} Backup olu≈üturuldu: {}", "üíæ".bright_blue(), backup_path.dimmed());
            }
            fs::write(&file_path, &change.new_content).await?;
        }
        "Delete" => {
            // Dosyayƒ± sil
            if file_path.exists() {
                fs::remove_file(&file_path).await?;
            }
        }
        _ => {
            println!("   {} Bilinmeyen deƒüi≈üiklik tipi: {}", "‚ö†Ô∏è".bright_yellow(), change.change_type);
        }
    }
    
    Ok(())
}

async fn handle_fix_actions(
    response: &FixResponse,
    error_message: &str,
    target_file: &Option<PathBuf>,
    client: &Client,
) -> Result<()> {
    let actions = vec![
        "üîÑ D√ºzeltmeyi test et",
        "üîç Benzer hatalarƒ± ara",
        "üí¨ Bu hata hakkƒ±nda soru sor",
        "üìö Hata hakkƒ±nda daha fazla bilgi al",
        "üìÅ Dosyayƒ± edit√∂rde a√ß",
        "‚ùå Hi√ßbiri",
    ];

    let selection = Select::with_theme(&ColorfulTheme::default())
        .with_prompt("Ne yapmak istiyorsunuz?")
        .items(&actions)
        .default(5)
        .interact_opt()?;

    if let Some(choice) = selection {
        match choice {
            0 => {
                test_fix(target_file).await?;
            }
            1 => {
                search_similar_errors(error_message, client).await?;
            }
            2 => {
                println!("{}", "üí¨ Soru sorma √∂zelliƒüi yakƒ±nda eklenecek!".bright_yellow());
                // TODO: Interactive Q&A about the error
            }
            3 => {
                get_more_error_info(error_message, client).await?;
            }
            4 => {
                if let Some(file) = target_file {
                    open_file_in_editor(file).await?;
                }
            }
            _ => {}
        }
    }

    Ok(())
}

async fn test_fix(target_file: &Option<PathBuf>) -> Result<()> {
    println!("{}", "üß™ D√ºzeltme test ediliyor...".bright_yellow());

    // Proje tipine g√∂re test komutu belirle
    let test_commands = [
        ("cargo", vec!["check"]),
        ("cargo", vec!["test"]),
        ("npm", vec!["test"]),
        ("python", vec!["-m", "pytest"]),
        ("mvn", vec!["test"]),
        ("make", vec!["test"]),
    ];

    for (cmd, args) in &test_commands {
        if std::process::Command::new("which")
            .arg(cmd)
            .output()
            .map(|output| output.status.success())
            .unwrap_or(false)
        {
            println!("{} {} √ßalƒ±≈ütƒ±rƒ±lƒ±yor...", "üî®".bright_blue(), cmd);
            
            let output = std::process::Command::new(cmd)
                .args(args)
                .output();

            if let Ok(result) = output {
                if result.status.success() {
                    println!("{} Test ba≈üarƒ±lƒ±!", "‚úÖ".bright_green());
                    let stdout = String::from_utf8_lossy(&result.stdout);
                    if !stdout.trim().is_empty() {
                        println!("{}", stdout.trim().dimmed());
                    }
                    return Ok(());
                } else {
                    println!("{} Test ba≈üarƒ±sƒ±z:", "‚ùå".bright_red());
                    let stderr = String::from_utf8_lossy(&result.stderr);
                    if !stderr.trim().is_empty() {
                        println!("{}", stderr.trim().bright_red());
                    }
                }
            }
        }
    }

    println!("{}", "‚ö†Ô∏è Uygun test komutu bulunamadƒ±.".bright_yellow());
    Ok(())
}

async fn search_similar_errors(error_message: &str, client: &Client) -> Result<()> {
    println!("{}", "üîç Benzer hatalar aranƒ±yor...".bright_yellow());
    search_error_solutions(error_message, client).await
}

async fn get_more_error_info(error_message: &str, client: &Client) -> Result<()> {
    println!("{}", "üìö Hata hakkƒ±nda daha fazla bilgi alƒ±nƒ±yor...".bright_yellow());
    
    let info_request = FixRequest {
        session_id: None,
        message: format!("Bu hata tipi hakkƒ±nda detaylƒ± bilgi ver: {}\n\nL√ºtfen:\n1. Bu hatanƒ±n yaygƒ±n nedenlerini a√ßƒ±kla\n2. √ñnleme y√∂ntemlerini anlat\n3. ƒ∞lgili best practice'leri payla≈ü", error_message),
        current_file: None,
        selected_text: None,
        context_files: Vec::new(),
        intent_hint: Some("Documentation".to_string()),
    };

    match client.post::<FixResponse, _>("/conversation/message", &info_request).await {
        Ok(response) => {
            println!();
            println!("{}", "üìñ Hata Hakkƒ±nda Detaylƒ± Bilgi".bright_blue().bold());
            println!("{}", "=".repeat(60).bright_blue());
            println!("{}", response.response.ai_response);
        }
        Err(e) => {
            println!("{} {}", "‚ùå Bilgi alƒ±namadƒ±:".bright_red(), e);
        }
    }

    Ok(())
}

async fn open_file_in_editor(file_path: &PathBuf) -> Result<()> {
    let editors = ["code", "vim", "nano", "gedit"];
    
    for editor in &editors {
        if std::process::Command::new("which")
            .arg(editor)
            .output()
            .map(|output| output.status.success())
            .unwrap_or(false)
        {
            println!("{} {} ile a√ßƒ±lƒ±yor: {}", 
                "üìù".bright_blue(), 
                editor, 
                file_path.display().to_string().bright_white()
            );
            
            match std::process::Command::new(editor)
                .arg(file_path)
                .spawn()
            {
                Ok(_) => {
                    println!("{}", "‚úÖ Dosya a√ßƒ±ldƒ±!".bright_green());
                    return Ok(());
                }
                Err(e) => {
                    println!("{} {} ile a√ßƒ±lamadƒ±: {}", "‚ö†Ô∏è".bright_yellow(), editor, e);
                }
            }
        }
    }
    
    println!("{}", "‚ùå Uygun edit√∂r bulunamadƒ±. Dosya yolu:".bright_red());
    println!("{}", file_path.display().to_string().bright_white());
    Ok(())
}